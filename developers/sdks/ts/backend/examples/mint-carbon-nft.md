# Minting a New Carbon NFT

To mint a new Carbon NFT, you first need to obtain both the Carbon token ID and the Carbon token series ID.
These identifiers are returned from the token creation transaction and series creation transaction, respectively.

## Minting a New Carbon NFT

The following code snippet demonstrates how to mint a new Carbon NFT.

### Imports

These are the imports typically required for minting a Carbon NFT:

```ts
import {
  Bytes32,
  getRandomPhantasmaId,
  MintNftFeeOptions,
  MintNonFungibleTxHelper,
  NftRomBuilder,
  PhantasmaAPI,
  PhantasmaKeys,
} from "phantasma-sdk-ts";
````

### Initialize Deployer Keys

In the following examples, we will use the deployerâ€™s `PhantasmaKeys` keypair and its `Bytes32` public key.

```ts
  // Initialize PhantasmaKeys using WIF-encoded private key
  const txSender = PhantasmaKeys.fromWIF("KwPpBSByydVKqStGHAnZzQofCqhDmD2bfRgc9BmZqM3ZmsdWJw4d");
  // Get the public key from the keypair
  const senderPubKey = new Bytes32(txSender.PublicKey);
````

### Build NFT ROM

`NftRomBuilder` helps construct and serialize the NFT ROM.

```ts
  // First we need to generate a new random Phantasma ID for the new NFT
  const newPhantasmaNftId = await getRandomPhantasmaId();

  const rom = NftRomBuilder.buildAndSerialize(
    newPhantasmaNftId,
    cfg.metadataName, // NFT name
    cfg.metadataDescription, // NFT description
    cfg.metadataImageUrl, // NFT image URL (or IPFS URL)
    cfg.metadataInfoUrl, // NFT information URL
    cfg.metadataRoyalties, // NFT royalties. 10000000 = 1%
    new Uint8Array(), // Optional Smart NFT ROM compatible with Phantasma VM and NFT's smart contract (leave empty if unsure)
  );
````

### Set NFT Minting Fees

`MintNftFeeOptions` is used to specify the fees for NFT minting.
You can call the constructor without arguments to use default values.

```ts
  const feeOptions = new MintNftFeeOptions(
    10000, // Base fee
    10000 // Fee multiplier
  );
````

### Build and Sign the Transaction

`MintNonFungibleTxHelper` simplifies the process of building and signing the NFT minting transaction.

```ts
  const tx = MintNonFungibleTxHelper.buildTxAndSignHex(
    carbonTokenId, // Carbon token ID to which the new NFT will be attached
    carbonSeriesId, // Carbon token series ID to which the new NFT will be attached
    txSender, // Keypair used to sign the transaction
    senderPubKey, // Public key of new NFT owner
    rom, // ROM generated by NftRomBuilder. It's mandatory
    new Uint8Array(), // NFT's RAM, optional
    feeOptions, // Fee options defined above
    100000000, // Mint NFT max data (use this default value if unsure)
  );
````

### Broadcast the Transaction

Broadcast the transaction to the network.

```ts
  const rpc = new PhantasmaAPI("https://testnet.phantasma.info/rpc", null, "testnet");

  // Use sendCarbonTransaction() to call Carbon methods
  const txHash = await rpc.sendCarbonTransaction(tx);
````

### Parse the Result

After the transaction is mined and its result becomes available, parse it to obtain the new Carbon NFT address.
This address can later be used for infusion.

The method `MintNonFungibleTxHelper.parseResult()` returns an array of minted NFT addresses -
in this case, it will contain a single element.

```ts
  // Wait for transaction confirmation...

  if (success) {
    const carbonNftAddresses = MintNonFungibleTxHelper.parseResult(
      carbonTokenId,
      result,
    );
    console.log(
      `Deployed NFT with phantasma ID ${newPhantasmaNftId} and carbon NFT address ${carbonNftAddresses[0]}`
    );
  } else {
    console.log("Could not mint NFT");
  }
```
